#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const packageJson = require("../package.json");

/**
 * Generate YML metadata files for electron-updater
 * This script creates the necessary metadata files that electron-updater expects
 * for auto-update functionality on different platforms.
 */

function calculateFileHash(filePath) {
  const fileBuffer = fs.readFileSync(filePath);
  const hashSum = crypto.createHash("sha512");
  hashSum.update(fileBuffer);
  return hashSum.digest("base64");
}

function getFileSize(filePath) {
  const stats = fs.statSync(filePath);
  return stats.size;
}

function findFilesInMakeDir(filePattern) {
  const makeDir = path.join(__dirname, "../out/make");
  const foundFiles = [];

  function searchDirectory(dir, depth = 0) {
    if (depth > 5) return; // Prevent infinite recursion
    
    try {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const itemPath = path.join(dir, item);
        const stat = fs.statSync(itemPath);
        
        if (stat.isDirectory()) {
          // Recursively search subdirectories
          searchDirectory(itemPath, depth + 1);
        } else if (stat.isFile()) {
          // Check if file matches the pattern
          if (filePattern.test(item)) {
            foundFiles.push({
              path: itemPath,
              name: item,
              relativePath: path.relative(makeDir, itemPath)
            });
          }
        }
      }
    } catch (error) {
      // Ignore directories we can't read
      console.warn(`Warning: Could not read directory ${dir}: ${error.message}`);
    }
  }

  // Start searching from the make directory
  searchDirectory(makeDir);
  
  return foundFiles;
}

function generateMacYml() {
  const version = packageJson.version;
  const makeDir = path.join(__dirname, "../out/make");

  // Look for the ZIP file (latest version) using dynamic search
  const zipPattern = new RegExp(`.*-darwin-arm64-${version}\\.zip$|.*-MacOS-arm64-${version}\\.zip$`);
  const zipFiles = findFilesInMakeDir(zipPattern);

  if (zipFiles.length === 0) {
    console.error("No ZIP file found for version:", version);
    console.log("Searched for pattern:", zipPattern.toString());
    return;
  }

  // Take the first matching file
  const zipFile = zipFiles[0];
  const zipPath = zipFile.path;

  const hash = calculateFileHash(zipPath);
  const size = getFileSize(zipPath);

  // Generate the YML content for macOS
  // When using GitHub provider, use just the filename - electron-updater will construct the full URL
  const ymlContent = `version: ${version}
files:
  - url: ${zipFile.name}
    sha512: ${hash}
    size: ${size}
    blockMapSize: 0
path: ${zipFile.name}
sha512: ${hash}
releaseDate: ${new Date().toISOString()}
`;

  // Write the YML file
  const ymlPath = path.join(makeDir, "latest-mac.yml");
  fs.writeFileSync(ymlPath, ymlContent);

  console.log("Generated latest-mac.yml:", ymlPath);
  console.log("Found ZIP file:", zipFile.relativePath);
  console.log("Content:");
  console.log(ymlContent);

  return ymlPath;
}

function generateWinYml() {
  // Windows YML should already be generated by electron-forge-maker-squirrel
  // But we can create a backup if needed
  const version = packageJson.version;
  const makeDir = path.join(__dirname, "../out/make");

  // Look for the Windows installer using dynamic search
  const winPattern = new RegExp(`.*-${version}.*\\.exe$`);
  const winFiles = findFilesInMakeDir(winPattern);

  if (winFiles.length === 0) {
    console.log("No Windows installer found for version:", version);
    console.log("Searched for pattern:", winPattern.toString());
    return;
  }

  const winFile = winFiles[0];
  const winPath = winFile.path;

  const hash = calculateFileHash(winPath);
  const size = getFileSize(winPath);

  // Generate the YML content for Windows
  // When using GitHub provider, use just the filename - electron-updater will construct the full URL
  const ymlContent = `version: ${version}
files:
  - url: ${winFile.name}
    sha512: ${hash}
    size: ${size}
path: ${winFile.name}
sha512: ${hash}
releaseDate: ${new Date().toISOString()}
`;

  const ymlPath = path.join(makeDir, "latest.yml");
  fs.writeFileSync(ymlPath, ymlContent);

  console.log("Generated latest.yml:", ymlPath);
  console.log("Found Windows installer:", winFile.relativePath);
  return ymlPath;
}

function generateLinuxYml() {
  const version = packageJson.version;
  const makeDir = path.join(__dirname, "../out/make");

  // Look for the Linux package (DEB or AppImage) using dynamic search
  const linuxPattern = new RegExp(`.*-${version}.*\\.(deb|AppImage)$`);
  const linuxFiles = findFilesInMakeDir(linuxPattern);

  if (linuxFiles.length === 0) {
    console.log("No Linux package found for version:", version);
    console.log("Searched for pattern:", linuxPattern.toString());
    return;
  }

  const linuxFile = linuxFiles[0]; // Take the first matching file (DEB or AppImage)
  const linuxPath = linuxFile.path;

  const hash = calculateFileHash(linuxPath);
  const size = getFileSize(linuxPath);

  // Generate the YML content for Linux
  // When using GitHub provider, use just the filename - electron-updater will construct the full URL
  const ymlContent = `version: ${version}
files:
  - url: ${linuxFile.name}
    sha512: ${hash}
    size: ${size}
path: ${linuxFile.name}
sha512: ${hash}
releaseDate: ${new Date().toISOString()}
`;

  // Write the YML file
  const ymlPath = path.join(makeDir, "latest-linux.yml");
  fs.writeFileSync(ymlPath, ymlContent);

  console.log("Generated latest-linux.yml:", ymlPath);
  console.log("Found Linux package:", linuxFile.relativePath);
  console.log("Content:");
  console.log(ymlContent);

  return ymlPath;
}

function main() {
  console.log("Generating YML metadata files for electron-updater...");

  try {
    const macYml = generateMacYml();
    const winYml = generateWinYml();
    const linuxYml = generateLinuxYml();

    console.log("\nYML files generated successfully!");
    console.log("Make sure to upload these files along with your release assets to GitHub.");
  } catch (error) {
    console.error("Error generating YML files:", error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = {
  generateMacYml,
  generateWinYml,
  generateLinuxYml,
};
